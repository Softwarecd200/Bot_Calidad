# -*- coding: utf-8 -*-
"""Copia de V7_QUA_FINAL_COLAB_2025_02_24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OJSQyX_OQiWtQB1rzkv7QDZbsZX__k7z
"""

# Instalar bibliotecas necesarias
!pip install sodapy
!pip install hubspot-api-client
!pip install SpeechRecognition
!pip install requests
!pip install -qU langchain-google-vertexai
!pip install google-cloud
!pip install langchain-google-vertexai
!pip install -qU langchain-google-genai
!pip install matplotlib  # Para gráficos semaforizados

# Importar bibliotecas
import speech_recognition as sr
import pandas as pd
from hubspot import HubSpot
from hubspot.crm.objects import ApiException, PublicObjectSearchRequest
import datetime
import requests
from langchain_google_genai import ChatGoogleGenerativeAI
import os
import getpass
from IPython.display import display
import ipywidgets as widgets
import matplotlib.pyplot as plt  # Para gráficos semaforizados

# Solicitar y configurar la clave de HubSpot de manera segura
if "HUBSPOT_ACCESS_TOKEN" not in os.environ:
    hubspot_token = getpass.getpass("Introduce tu clave de API de HubSpot: ")
    os.environ["HUBSPOT_ACCESS_TOKEN"] = hubspot_token

# Solicitar y configurar la clave de Google de manera segura
if "GOOGLE_API_KEY" not in os.environ:
    google_api_key = getpass.getpass("Introduce tu clave de API de Google: ")
    os.environ["GOOGLE_API_KEY"] = google_api_key

# Inicializar el cliente de HubSpot
client = HubSpot(access_token=os.environ["HUBSPOT_ACCESS_TOKEN"])

# Solicitar el rango de fechas desde el teclado
fecha_desde = input("Introduce la fecha de inicio (YYYY-MM-DD): ")
fecha_hasta = input("Introduce la fecha de fin (YYYY-MM-DD): ")

# Convertir las fechas a objetos datetime
fecha_desde_dt = datetime.datetime.strptime(fecha_desde, "%Y-%m-%d")
fecha_hasta_dt = datetime.datetime.strptime(fecha_hasta, "%Y-%m-%d")

# Convertir las fechas a timestamp UNIX en milisegundos
fecha_desde_timestamp = int(fecha_desde_dt.timestamp() * 1000)
fecha_hasta_timestamp = int(fecha_hasta_dt.timestamp() * 1000)

# Definir la búsqueda
search_request = PublicObjectSearchRequest(
    filter_groups=[{
        "filters": [
            {
                "propertyName": "hs_createdate",
                "operator": "GTE",
                "value": str(fecha_desde_timestamp)
            },
            {
                "propertyName": "hs_createdate",
                "operator": "LTE",
                "value": str(fecha_hasta_timestamp)
            }
        ]
    }],
    properties=["hs_call_recording_url", "hs_createdate"]
)

try:
    # Realizar la búsqueda
    api_response = client.crm.objects.search_api.do_search("calls", search_request)
    results = api_response.results

    # Extraer los call IDs y URLs de grabación
    call_ids = [result.id for result in results]
    recording_urls = [result.properties.get("hs_call_recording_url") for result in results]

    # Filtrar las llamadas que tienen una URL de grabación válida
    valid_calls = [{"Call ID": call_id, "Recording URL": url} for call_id, url in zip(call_ids, recording_urls) if url]

    # Crear un DataFrame con los resultados
    df = pd.DataFrame(valid_calls)

    print(f"Se encontraron {len(df)} llamadas con grabaciones válidas.")

    # Mostrar un máximo de 5 llamadas
    max_calls = min(5, len(df))
    df_sample = df.head(max_calls)
    print(df_sample)

    if df_sample.empty:
        print("No se encontraron llamadas con grabaciones.")
    else:
        # Crear checkboxes para seleccionar las llamadas
        checkboxes = [widgets.Checkbox(value=False, description=f"Call ID: {row['Call ID']}") for index, row in df_sample.iterrows()]
        display(widgets.VBox(checkboxes))

        # Botón para enviar la selección
        button = widgets.Button(description="Enviar")
        display(button)

        # Función para manejar el clic del botón
        def on_button_click(b):
            selected_call_ids = [df_sample.iloc[i]["Call ID"] for i, checkbox in enumerate(checkboxes) if checkbox.value]
            if not selected_call_ids:
                print("No se seleccionaron llamadas para transcribir.")
                return

            # Función para descargar una llamada
            def download_call_audio(call_id, recording_url):
                try:
                    headers = {
                        "Authorization": f"Bearer {os.environ['HUBSPOT_ACCESS_TOKEN']}"
                    }
                    response = requests.get(recording_url, headers=headers)
                    response.raise_for_status()  # Esto lanzará una excepción si la solicitud no fue exitosa
                    audio_file_path = f"{call_id}.wav"
                    with open(audio_file_path, "wb") as audio_file:
                        audio_file.write(response.content)
                    print(f"Grabación de la llamada {call_id} descargada correctamente en formato .wav.")
                    return audio_file_path
                except requests.exceptions.HTTPError as e:
                    print(f"Error al descargar la grabación: {e}")
                    return None

            # Función para transcribir una llamada
            def transcribe_audio_to_text(audio_file_path):
                recognizer = sr.Recognizer()
                try:
                    with sr.AudioFile(audio_file_path) as source:
                        audio_data = recognizer.record(source)
                    text = recognizer.recognize_google(audio_data, language="es-ES")
                    print("Transcripción completa:")
                    print(text)
                    return text
                except sr.UnknownValueError:
                    print("Google Speech Recognition no pudo entender el audio.")
                    return None
                except sr.RequestError as e:
                    print(f"Error al solicitar resultados de Google Speech Recognition: {e}")
                    return None
                except Exception as e:
                    print(f"Error inesperado durante la transcripción: {e}")
                    return None

            # Inicializar el modelo de Google Vertex AI
            llm = ChatGoogleGenerativeAI(
                model="gemini-1.5-pro",
                temperature=0,
                max_tokens=None,
                timeout=None,
                max_retries=2,
            )

            # Función para analizar una transcripción
            def analyze_transcription(transcription):
                messages = [
                    {
                        "role": "system",
                        "content": """
Eres un experto en feedback y ventas por teléfono. Tu objetivo es analizar una conversación que te voy a proporcionar y evaluar su cumplimiento con los PASOS OBLIGATORIOS (✅). Sigue las siguientes pautas para dar feedback:

###
PASOS OBLIGATORIOS (✅)

1. **Apertura**:
   - Saludo casual ("¡Hola!")
   - Usar solo el nombre del lead (sin Sr./Sra./Don/Doña)
   - Presentarte solo con tu nombre (sin apellido)
   - Mencionar que llamas del Taller de Bienes Raíces con Carlos Devis

2. **Romper el hielo**:
   - Elegir UN solo tema: ciudad, clima, gastronomía o lugares turísticos
   - Hacer preguntas sobre el tema elegido

3. **Identificación del dolor/necesidad**:
   - Preguntar motivación sobre bienes raíces
   - Identificar obstáculos
   - Si no es claro, profundizar con preguntas sobre:
     - Ahorros
     - Situación financiera
     - Fuente de ingresos
     - Situación personal
   - Confirmar el dolor identificado con el lead

4. **Presentación de credenciales**:
   - Mencionar los 700+ testimonios de éxito
   - Compartir un ejemplo relevante al caso del lead
   - Preguntar si quisieran lograr resultados similares

5. **Presentación de la metodología**:
   - Explicar los 5 pasos:
     - Cambio de pensamiento
     - Organización financiera
     - Ahorrar
     - Invertir
     - Repetir el proceso

6. **Verificar dudas**:
   - Preguntar si hay dudas o preguntas

7. **Presentación de programas**:
   - Mencionar las dos opciones principales:
     - Programa Avanzado ($1,497 USD)
     - Programa Mentoría ($4,999 USD)

8. **Cierre (Obligatorio)**:
   - Mencionar SIEMPRE el precio de página
   - Ofrecer SIEMPRE precio promocional
   - Dar máximo 48 horas de plazo como último recurso

###

Para cada paso, indica si se cumplió (✅) o no (❌) y proporciona una explicación breve. Al final, da una calificación única de 0 a 5 siendo 5 una llamada perfecta. Además, proporciona sugerencias de mejora para cada paso no cumplido.
"""
                    },
                    {
                        "role": "user",
                        "content": transcription
                    }
                ]

                # Invocar el modelo de Google Vertex AI
                ai_msg = llm.invoke(messages)
                return ai_msg.content

            # Procesar las llamadas seleccionadas
            resultados = []
            for call_id in selected_call_ids:
                recording_url = df_sample.loc[df_sample['Call ID'] == call_id, 'Recording URL'].values[0]

                print(f"\nProcesando llamada {call_id}...")

                # Descargar la grabación
                audio_file_path = download_call_audio(call_id, recording_url)

                # Si no se puede descargar, omitir la llamada
                if not audio_file_path:
                    print(f"La llamada {call_id} no pudo ser descargada y se omitirá del análisis.")
                    continue

                # Transcribir el audio a texto
                transcription = transcribe_audio_to_text(audio_file_path)

                # Si no se puede transcribir, omitir la llamada
                if not transcription:
                    print(f"La llamada {call_id} no pudo ser transcrita y se omitirá del análisis.")
                    continue

                # Analizar la transcripción
                analisis = analyze_transcription(transcription)
                resultados.append({
                    "Call ID": call_id,
                    "Transcription": transcription,
                    "Analysis": analisis
                })

            # Si no hay resultados válidos, terminar el proceso
            if not resultados:
                print("No hay llamadas válidas para analizar.")
                return

            # Crear un DataFrame con los resultados
            df_resultados = pd.DataFrame(resultados)

            # Guardar los resultados en un archivo CSV
            df_resultados.to_csv("analisis_llamadas.csv", index=False)
            print("\nAnálisis de llamadas guardado en 'analisis_llamadas.csv'.")

            # Mostrar el informe final en un formato estructurado
            print("\nInforme de Análisis de Llamadas:")
            for index, row in df_resultados.iterrows():
                print(f"\nLlamada ID: {row['Call ID']}")
                print("Transcripción:")
                print(row["Transcription"])
                print("\nAnálisis y Diagnóstico:")
                print(row["Analysis"])
                print("-" * 80)

            # Análisis general de todas las llamadas
            def extract_rating(analysis):
                # Extraer la calificación del análisis (asumiendo que está al final del texto)
                lines = analysis.split('\n')
                for line in lines:
                    if "calificación única de" in line:
                        return float(line.split()[-1])
                return 0

            df_resultados['Rating'] = df_resultados['Analysis'].apply(extract_rating)
            promedio_calificaciones = df_resultados['Rating'].mean()

            # Determinar el color del semáforo
            if promedio_calificaciones >= 4:
                color_semaforo = "green"
                estado_semaforo = "Verde (Excelente)"
            elif 2.5 <= promedio_calificaciones < 4:
                color_semaforo = "yellow"
                estado_semaforo = "Amarillo (Regular)"
            else:
                color_semaforo = "red"
                estado_semaforo = "Rojo (Deficiente)"

            # Mostrar el promedio y el estado del semáforo
            print(f"\nPromedio de Calificaciones: {promedio_calificaciones:.2f}/5.0")
            print(f"Estado del Semáforo: {estado_semaforo}")

            # Crear un gráfico semaforizado
            plt.figure(figsize=(10, 2))
            plt.barh(0, promedio_calificaciones, color=color_semaforo)
            plt.xlim(0, 5)
            plt.title("Resultado General del Análisis (Semaforizado)")
            plt.xlabel("Calificación Promedio")
            plt.yticks([])
            plt.show()

            # Generar un diagnóstico general
            messages_general = [
                {
                    "role": "system",
                    "content": """
Eres un experto en feedback y ventas por teléfono. Tu objetivo es proporcionar un diagnóstico general y sugerencias de mejora basado en el análisis de varias llamadas. Considera el promedio de calificaciones y los puntos comunes de mejora.

###
DIAGNÓSTICO GENERAL Y SUGERENCIAS

1. **Promedio de Calificaciones**: {promedio_calificaciones:.2f}/5.0
2. **Puntos Fuertes**:
   - [Lista de puntos fuertes comunes]
3. **Áreas de Mejora**:
   - [Lista de áreas de mejora comunes]
4. **Sugerencias**:
   - [Sugerencias generales para mejorar las llamadas]
"""
                },
                {
                    "role": "user",
                    "content": "\n".join(df_resultados['Analysis'])
                }
            ]

            # Invocar el modelo de Google Vertex AI para el diagnóstico general
            diagnostico_general = llm.invoke(messages_general)
            print("\nDiagnóstico General y Sugerencias:")
            print(diagnostico_general.content)

        # Asignar la función al botón
        button.on_click(on_button_click)

except ApiException as e:
    print("Exception when calling search_api->do_search: %s\n" % e)
except IndexError:
    print("No se encontraron URLs de grabación válidas.")